// Code generated by mockery v2.0.0. DO NOT EDIT.

package mocks

import (
	context "context"

	client "github.com/micro/go-micro/v2/client"

	mock "github.com/stretchr/testify/mock"

	service_transaction "orders-system/proto/service_transaction"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
	mock.Mock
}

// AccountingChangeGpay provides a mock function with given fields: ctx, in, opts
func (_m *Service) AccountingChangeGpay(ctx context.Context, in *service_transaction.AccountingChangeGpayRequest, opts ...client.CallOption) (*service_transaction.AccountingChangeGpayRequest, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.AccountingChangeGpayRequest
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.AccountingChangeGpayRequest, ...client.CallOption) *service_transaction.AccountingChangeGpayRequest); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.AccountingChangeGpayRequest)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.AccountingChangeGpayRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountingPromotion provides a mock function with given fields: ctx, in, opts
func (_m *Service) AccountingPromotion(ctx context.Context, in *service_transaction.AccountingPromotionRequest, opts ...client.CallOption) (*service_transaction.AccountingPromotionRequest, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.AccountingPromotionRequest
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.AccountingPromotionRequest, ...client.CallOption) *service_transaction.AccountingPromotionRequest); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.AccountingPromotionRequest)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.AccountingPromotionRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountingPromotionDeposit provides a mock function with given fields: ctx, in, opts
func (_m *Service) AccountingPromotionDeposit(ctx context.Context, in *service_transaction.AccountingPromotionDepositRequest, opts ...client.CallOption) (*service_transaction.AccountingPromotionDepositRequest, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.AccountingPromotionDepositRequest
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.AccountingPromotionDepositRequest, ...client.CallOption) *service_transaction.AccountingPromotionDepositRequest); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.AccountingPromotionDepositRequest)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.AccountingPromotionDepositRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountingPromotionWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *Service) AccountingPromotionWithdraw(ctx context.Context, in *service_transaction.AccountingPromotionWithdrawRequest, opts ...client.CallOption) (*service_transaction.AccountingPromotionWithdrawRequest, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.AccountingPromotionWithdrawRequest
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.AccountingPromotionWithdrawRequest, ...client.CallOption) *service_transaction.AccountingPromotionWithdrawRequest); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.AccountingPromotionWithdrawRequest)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.AccountingPromotionWithdrawRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountingSettlement provides a mock function with given fields: ctx, in, opts
func (_m *Service) AccountingSettlement(ctx context.Context, in *service_transaction.AccountingSettlementRequest, opts ...client.CallOption) (*service_transaction.AccountingSettlementRequest, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.AccountingSettlementRequest
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.AccountingSettlementRequest, ...client.CallOption) *service_transaction.AccountingSettlementRequest); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.AccountingSettlementRequest)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.AccountingSettlementRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountingTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Service) AccountingTransaction(ctx context.Context, in *service_transaction.AccountingTransactionRequest, opts ...client.CallOption) (*service_transaction.AccountingTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.AccountingTransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.AccountingTransactionRequest, ...client.CallOption) *service_transaction.AccountingTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.AccountingTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.AccountingTransactionRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelRefundTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Service) CancelRefundTransaction(ctx context.Context, in *service_transaction.CancelRefundTransactionRequest, opts ...client.CallOption) (*service_transaction.RefundTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.RefundTransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.CancelRefundTransactionRequest, ...client.CallOption) *service_transaction.RefundTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.RefundTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.CancelRefundTransactionRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Service) CancelTransaction(ctx context.Context, in *service_transaction.ETransactionDTO, opts ...client.CallOption) (*service_transaction.ETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) *service_transaction.ETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelTransactionId provides a mock function with given fields: ctx, in, opts
func (_m *Service) CancelTransactionId(ctx context.Context, in *service_transaction.CancelTransactionIdRequest, opts ...client.CallOption) (*service_transaction.CancelTransactionIdResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.CancelTransactionIdResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.CancelTransactionIdRequest, ...client.CallOption) *service_transaction.CancelTransactionIdResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.CancelTransactionIdResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.CancelTransactionIdRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChangeStatusChecking provides a mock function with given fields: ctx, in, opts
func (_m *Service) ChangeStatusChecking(ctx context.Context, in *service_transaction.ChangeStatusCheckingRequest, opts ...client.CallOption) (*service_transaction.ChangeStatusCheckingRequest, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ChangeStatusCheckingRequest
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ChangeStatusCheckingRequest, ...client.CallOption) *service_transaction.ChangeStatusCheckingRequest); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ChangeStatusCheckingRequest)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ChangeStatusCheckingRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChangeStatusSettlement provides a mock function with given fields: ctx, in, opts
func (_m *Service) ChangeStatusSettlement(ctx context.Context, in *service_transaction.ChangeStatusSettlementRequest, opts ...client.CallOption) (*service_transaction.ChangeStatusSettlementRequest, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ChangeStatusSettlementRequest
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ChangeStatusSettlementRequest, ...client.CallOption) *service_transaction.ChangeStatusSettlementRequest); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ChangeStatusSettlementRequest)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ChangeStatusSettlementRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckPendingTransactionShip provides a mock function with given fields: ctx, in, opts
func (_m *Service) CheckPendingTransactionShip(ctx context.Context, in *service_transaction.CheckPendingTransactionRequest, opts ...client.CallOption) (*service_transaction.CheckPendingTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.CheckPendingTransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.CheckPendingTransactionRequest, ...client.CallOption) *service_transaction.CheckPendingTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.CheckPendingTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.CheckPendingTransactionRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckTransactionLimitFee provides a mock function with given fields: ctx, in, opts
func (_m *Service) CheckTransactionLimitFee(ctx context.Context, in *service_transaction.CheckTransactionLimitFeeRequest, opts ...client.CallOption) (*service_transaction.CheckTransactionLimitFeeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.CheckTransactionLimitFeeResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.CheckTransactionLimitFeeRequest, ...client.CallOption) *service_transaction.CheckTransactionLimitFeeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.CheckTransactionLimitFeeResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.CheckTransactionLimitFeeRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckTransactionQuotaAndFee provides a mock function with given fields: ctx, in, opts
func (_m *Service) CheckTransactionQuotaAndFee(ctx context.Context, in *service_transaction.CheckTransactionQuotaAndFeeReq, opts ...client.CallOption) (*service_transaction.CheckTransactionQuotaAndFeeRes, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.CheckTransactionQuotaAndFeeRes
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.CheckTransactionQuotaAndFeeReq, ...client.CallOption) *service_transaction.CheckTransactionQuotaAndFeeRes); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.CheckTransactionQuotaAndFeeRes)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.CheckTransactionQuotaAndFeeReq, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfirmRefundTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Service) ConfirmRefundTransaction(ctx context.Context, in *service_transaction.ConfirmRefundTransactionRequest, opts ...client.CallOption) (*service_transaction.RefundTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.RefundTransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ConfirmRefundTransactionRequest, ...client.CallOption) *service_transaction.RefundTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.RefundTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ConfirmRefundTransactionRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfirmTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Service) ConfirmTransaction(ctx context.Context, in *service_transaction.ETransactionDTO, opts ...client.CallOption) (*service_transaction.ETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) *service_transaction.ETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountCheckFeeTransactionsByTimeRange provides a mock function with given fields: ctx, in, opts
func (_m *Service) CountCheckFeeTransactionsByTimeRange(ctx context.Context, in *service_transaction.CountCheckFeeTransactionsByTimeRangeReq, opts ...client.CallOption) (*service_transaction.CountCheckFeeTransactionsByTimeRangeRes, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.CountCheckFeeTransactionsByTimeRangeRes
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.CountCheckFeeTransactionsByTimeRangeReq, ...client.CallOption) *service_transaction.CountCheckFeeTransactionsByTimeRangeRes); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.CountCheckFeeTransactionsByTimeRangeRes)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.CountCheckFeeTransactionsByTimeRangeReq, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountTransactionsByTimeRange provides a mock function with given fields: ctx, in, opts
func (_m *Service) CountTransactionsByTimeRange(ctx context.Context, in *service_transaction.CountTransactionsRequest, opts ...client.CallOption) (*service_transaction.CountTransactionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.CountTransactionsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.CountTransactionsRequest, ...client.CallOption) *service_transaction.CountTransactionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.CountTransactionsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.CountTransactionsRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DepositGpay provides a mock function with given fields: ctx, in, opts
func (_m *Service) DepositGpay(ctx context.Context, in *service_transaction.DepositGpayRequest, opts ...client.CallOption) (*service_transaction.DepositGpayRequest, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.DepositGpayRequest
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.DepositGpayRequest, ...client.CallOption) *service_transaction.DepositGpayRequest); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.DepositGpayRequest)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.DepositGpayRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Service) FilterTransaction(ctx context.Context, in *service_transaction.FilterTransactionRequest, opts ...client.CallOption) (*service_transaction.FilterTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.FilterTransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.FilterTransactionRequest, ...client.CallOption) *service_transaction.FilterTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.FilterTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.FilterTransactionRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByTransactionId provides a mock function with given fields: ctx, in, opts
func (_m *Service) FindByTransactionId(ctx context.Context, in *service_transaction.FindByTransactionIdRequest, opts ...client.CallOption) (*service_transaction.FindByTransactionIdResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.FindByTransactionIdResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.FindByTransactionIdRequest, ...client.CallOption) *service_transaction.FindByTransactionIdResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.FindByTransactionIdResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.FindByTransactionIdRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindCheckFeeTransactionsByTimeRange provides a mock function with given fields: ctx, in, opts
func (_m *Service) FindCheckFeeTransactionsByTimeRange(ctx context.Context, in *service_transaction.FindCheckFeeTransactionsByTimeRangeReq, opts ...client.CallOption) (*service_transaction.ListETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ListETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.FindCheckFeeTransactionsByTimeRangeReq, ...client.CallOption) *service_transaction.ListETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ListETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.FindCheckFeeTransactionsByTimeRangeReq, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindRefundFeeTransactionsByTimeRange provides a mock function with given fields: ctx, in, opts
func (_m *Service) FindRefundFeeTransactionsByTimeRange(ctx context.Context, in *service_transaction.FindCheckFeeTransactionsByTimeRangeReq, opts ...client.CallOption) (*service_transaction.ListETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ListETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.FindCheckFeeTransactionsByTimeRangeReq, ...client.CallOption) *service_transaction.ListETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ListETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.FindCheckFeeTransactionsByTimeRangeReq, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTransactionByID provides a mock function with given fields: ctx, in, opts
func (_m *Service) FindTransactionByID(ctx context.Context, in *service_transaction.ETransactionDTO, opts ...client.CallOption) (*service_transaction.ETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) *service_transaction.ETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTransactionByParams provides a mock function with given fields: ctx, in, opts
func (_m *Service) FindTransactionByParams(ctx context.Context, in *service_transaction.ETransactionDTO, opts ...client.CallOption) (*service_transaction.ETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) *service_transaction.ETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTransactionsByIds provides a mock function with given fields: ctx, in, opts
func (_m *Service) FindTransactionsByIds(ctx context.Context, in *service_transaction.FindTransactionsByIdsReq, opts ...client.CallOption) (*service_transaction.ListETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ListETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.FindTransactionsByIdsReq, ...client.CallOption) *service_transaction.ListETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ListETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.FindTransactionsByIdsReq, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindVoidFeeTransactionsByTimeRange provides a mock function with given fields: ctx, in, opts
func (_m *Service) FindVoidFeeTransactionsByTimeRange(ctx context.Context, in *service_transaction.FindCheckFeeTransactionsByTimeRangeReq, opts ...client.CallOption) (*service_transaction.ListETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ListETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.FindCheckFeeTransactionsByTimeRangeReq, ...client.CallOption) *service_transaction.ListETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ListETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.FindCheckFeeTransactionsByTimeRangeReq, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCheckFeeSuccessTransactionStatsByTimeRange provides a mock function with given fields: ctx, in, opts
func (_m *Service) GetCheckFeeSuccessTransactionStatsByTimeRange(ctx context.Context, in *service_transaction.GetCheckFeeSuccessTransactionStatsByTimeRangeReq, opts ...client.CallOption) (*service_transaction.GetCheckFeeSuccessTransactionStatsByTimeRangeRes, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.GetCheckFeeSuccessTransactionStatsByTimeRangeRes
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.GetCheckFeeSuccessTransactionStatsByTimeRangeReq, ...client.CallOption) *service_transaction.GetCheckFeeSuccessTransactionStatsByTimeRangeRes); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.GetCheckFeeSuccessTransactionStatsByTimeRangeRes)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.GetCheckFeeSuccessTransactionStatsByTimeRangeReq, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionAmountByTimeRange provides a mock function with given fields: ctx, in, opts
func (_m *Service) GetTransactionAmountByTimeRange(ctx context.Context, in *service_transaction.GetTransactionAmountRequest, opts ...client.CallOption) (*service_transaction.GetTransactionAmountResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.GetTransactionAmountResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.GetTransactionAmountRequest, ...client.CallOption) *service_transaction.GetTransactionAmountResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.GetTransactionAmountResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.GetTransactionAmountRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserLimit provides a mock function with given fields: ctx, in, opts
func (_m *Service) GetUserLimit(ctx context.Context, in *service_transaction.CheckTransactionQuotaAndFeeReq, opts ...client.CallOption) (*service_transaction.GetUserLimitResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.GetUserLimitResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.CheckTransactionQuotaAndFeeReq, ...client.CallOption) *service_transaction.GetUserLimitResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.GetUserLimitResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.CheckTransactionQuotaAndFeeReq, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitMerchantAccount provides a mock function with given fields: ctx, in, opts
func (_m *Service) InitMerchantAccount(ctx context.Context, in *service_transaction.InitMerchantAccountReq, opts ...client.CallOption) (*service_transaction.InitMerchantAccountReq, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.InitMerchantAccountReq
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.InitMerchantAccountReq, ...client.CallOption) *service_transaction.InitMerchantAccountReq); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.InitMerchantAccountReq)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.InitMerchantAccountReq, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitPayment provides a mock function with given fields: ctx, in, opts
func (_m *Service) InitPayment(ctx context.Context, in *service_transaction.TransactionDTO, opts ...client.CallOption) (*service_transaction.InitTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.InitTransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.TransactionDTO, ...client.CallOption) *service_transaction.InitTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.InitTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.TransactionDTO, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Service) InitTransaction(ctx context.Context, in *service_transaction.ETransactionDTO, opts ...client.CallOption) (*service_transaction.ETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) *service_transaction.ETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MakePayment provides a mock function with given fields: ctx, in, opts
func (_m *Service) MakePayment(ctx context.Context, in *service_transaction.MakePaymentRequest, opts ...client.CallOption) (*service_transaction.MakePaymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.MakePaymentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.MakePaymentRequest, ...client.CallOption) *service_transaction.MakePaymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.MakePaymentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.MakePaymentRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessCashback provides a mock function with given fields: ctx, in, opts
func (_m *Service) ProcessCashback(ctx context.Context, in *service_transaction.ProcessCashbackRequest, opts ...client.CallOption) (*service_transaction.ProcessCashbackResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ProcessCashbackResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ProcessCashbackRequest, ...client.CallOption) *service_transaction.ProcessCashbackResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ProcessCashbackResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ProcessCashbackRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RefundTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Service) RefundTransaction(ctx context.Context, in *service_transaction.RefundTransactionRequest, opts ...client.CallOption) (*service_transaction.RefundTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.RefundTransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.RefundTransactionRequest, ...client.CallOption) *service_transaction.RefundTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.RefundTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.RefundTransactionRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReverseTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Service) ReverseTransaction(ctx context.Context, in *service_transaction.ETransactionDTO, opts ...client.CallOption) (*service_transaction.ETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) *service_transaction.ETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDecrementAmount provides a mock function with given fields: ctx, in, opts
func (_m *Service) UpdateDecrementAmount(ctx context.Context, in *service_transaction.UpdateDecrementAmountRequest, opts ...client.CallOption) (*service_transaction.UpdateDecrementAmountResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.UpdateDecrementAmountResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.UpdateDecrementAmountRequest, ...client.CallOption) *service_transaction.UpdateDecrementAmountResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.UpdateDecrementAmountResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.UpdateDecrementAmountRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIncrementAmount provides a mock function with given fields: ctx, in, opts
func (_m *Service) UpdateIncrementAmount(ctx context.Context, in *service_transaction.UpdateIncrementAmountRequest, opts ...client.CallOption) (*service_transaction.UpdateIncrementAmountResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.UpdateIncrementAmountResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.UpdateIncrementAmountRequest, ...client.CallOption) *service_transaction.UpdateIncrementAmountResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.UpdateIncrementAmountResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.UpdateIncrementAmountRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Service) UpdateTransaction(ctx context.Context, in *service_transaction.ETransactionDTO, opts ...client.CallOption) (*service_transaction.ETransactionDTO, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.ETransactionDTO
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) *service_transaction.ETransactionDTO); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.ETransactionDTO)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.ETransactionDTO, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTransactionById provides a mock function with given fields: ctx, in, opts
func (_m *Service) UpdateTransactionById(ctx context.Context, in *service_transaction.TransactionRequest, opts ...client.CallOption) (*service_transaction.UpdateTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.UpdateTransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.TransactionRequest, ...client.CallOption) *service_transaction.UpdateTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.UpdateTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.TransactionRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTransactionsByIds provides a mock function with given fields: ctx, in, opts
func (_m *Service) UpdateTransactionsByIds(ctx context.Context, in *service_transaction.UpdateTransactionsByIdsReq, opts ...client.CallOption) (*service_transaction.UpdateTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.UpdateTransactionResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.UpdateTransactionsByIdsReq, ...client.CallOption) *service_transaction.UpdateTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.UpdateTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.UpdateTransactionsByIdsReq, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateUserIncurred provides a mock function with given fields: ctx, in, opts
func (_m *Service) UpdateUserIncurred(ctx context.Context, in *service_transaction.UpdateUserIncurredRequest, opts ...client.CallOption) (*service_transaction.UpdateUserIncurredResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.UpdateUserIncurredResponse
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.UpdateUserIncurredRequest, ...client.CallOption) *service_transaction.UpdateUserIncurredResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.UpdateUserIncurredResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.UpdateUserIncurredRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawWallet provides a mock function with given fields: ctx, in, opts
func (_m *Service) WithdrawWallet(ctx context.Context, in *service_transaction.WithdrawWalletRequest, opts ...client.CallOption) (*service_transaction.WithdrawWalletRequest, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *service_transaction.WithdrawWalletRequest
	if rf, ok := ret.Get(0).(func(context.Context, *service_transaction.WithdrawWalletRequest, ...client.CallOption) *service_transaction.WithdrawWalletRequest); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*service_transaction.WithdrawWalletRequest)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *service_transaction.WithdrawWalletRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
